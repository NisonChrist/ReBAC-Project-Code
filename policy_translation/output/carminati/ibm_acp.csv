natural_language_statements,datalog_subjects,datalog_objects,datalog_relationships,datalog_actions,carminati
"""The system retrieves and displays the Student’s current schedule (e.g., the schedule for the current semester).""","Student(S), System(Sys).",Schedule(SC).,"has_current_schedule(S, SC) :- Student(S), Schedule(SC).","can_retrieve_and_display(Sys, S, SC) :- System(Sys), Student(S), Schedule(SC), has_current_schedule(S, SC).","System(?Sys) ∧ Student(?S) ∧ Schedule(?SC) ∧ has_current_schedule(?S,?SC) => can_retrieve_and_display(?Sys,?S,?SC)"
The system cancels the course offering for each schedule that contains it.,System(S).,"CourseOffering(CO), Schedule(SCH).","contains(SCH, CO) :- Schedule(SCH), CourseOffering(CO).","can_cancel(S, SCH, CO) :- System(S), Schedule(SCH), CourseOffering(CO), contains(SCH, CO).","System(?S) ∧ Schedule(?SCH) ∧ CourseOffering(?CO) ∧ contains(?SCH,?CO) => can_cancel(?S,?SCH,?CO)"
"""The system requests that the Registrar specify the function he or she would like to perform (either Add a Student, Update a Student, or Delete a Student)""",Registrar(R).,Student(S).,"can_perform(R, Function) :- Registrar(R), Function in {add_student, update_student, delete_student}.","specify_function(R, Function) :- Registrar(R), can_perform(R, Function).","Registrar(?R) ∧ can_perform(?R,?Function) => specify_function(?R,?Function)"
They will also need to see which students signed up for their course offerings.,"Instructor(I), Student(S).",CourseOffering(CO).,"teaches(I, CO) :- Instructor(I), CourseOffering(CO).
signed_up(S, CO) :- Student(S), CourseOffering(CO).","can_view_students(I, CO) :- Instructor(I), CourseOffering(CO), teaches(I, CO).
can_view_signed_up(I, S, CO) :- Instructor(I), Student(S), CourseOffering(CO), teaches(I, CO), signed_up(S, CO).","Instructor(?I) ∧ CourseOffering(?CO) ∧ teaches(?I,?CO). can_view_signed_up(I,?S,?CO) => can_view_students(?I,?CO)"
"""If no alternates are available, then no substitution will be made.""",Agent(A).,"Item(I), AlternateItem(ALT).","has_alternate(I, ALT) :- Item(I), AlternateItem(ALT).","can_substitute(A, I, ALT) :- Agent(A), Item(I), AlternateItem(ALT), has_alternate(I, ALT).","Agent(?A) ∧ Item(?I) ∧ AlternateItem(?ALT) ∧ has_alternate(?I,?ALT) => can_substitute(?A,?I,?ALT)"
The Student also selects any course offerings to delete from the existing schedule.,Student(S).,CourseOffering(CO).,"has_scheduled(S, CO) :- Student(S), CourseOffering(CO).","can_delete(S, CO) :- Student(S), CourseOffering(CO), has_scheduled(S, CO).","Student(?S) ∧ CourseOffering(?CO) ∧ has_scheduled(?S,?CO) => can_delete(?S,?CO)"
"""If a course offering becomes full while a student is building a schedule including that offering, the student must be notified.""",Student(S).,CourseOffering(CO).,"building_schedule(S, CO) :- Student(S), CourseOffering(CO).","must_notify(S, CO) :- Student(S), CourseOffering(CO), building_schedule(S, CO), is_full(CO).","Student(?S) ∧ CourseOffering(?CO) ∧ building_schedule(?S,?CO) ∧ is_full(?CO) => must_notify(?S,?CO)"
Only Professors can enter grades for students.,Professor(P).,"Student(S), Grade(G).","teaches(P, S) :- Professor(P), Student(S).","can_enter_grade(P, S, G) :- Professor(P), Student(S), Grade(G), teaches(P, S).","Professor(?P) ∧ Student(?S) ∧ Grade(?G) ∧ teaches(?P,?S) => can_enter_grade(?P,?S,?G)"
The professor selects possibly and possibly de-selects the course offerings that he or she wishes to teach for the upcoming semester.,Professor(P).,CourseOffering(C).,"wishes_to_teach(P, C) :- Professor(P), CourseOffering(C).","can_select(P, C) :- Professor(P), CourseOffering(C), wishes_to_teach(P, C). can_deselect(P, C) :- Professor(P), CourseOffering(C), wishes_to_teach(P, C).","Professor(?P) ∧ CourseOffering(?C) ∧ wishes_to_teach(?P,?C). can_deselect(P,?C) => can_select(?P,?C)"
The professor is added to the system.,Professor(P).,System(S).,"added_to(P, S) :- Professor(P), System(S).","can_access(P, S) :- Professor(P), System(S), added_to(P, S).","Professor(?P) ∧ System(?S) ∧ added_to(?P,?S) => can_access(?P,?S)"
The Student selects 4 primary course offerings and 2 alternate course offerings from the list of available offerings.,Student(S).,CourseOffering(CO).,"selects_primary(S, CO) :- Student(S), CourseOffering(CO).
selects_alternate(S, CO) :- Student(S), CourseOffering(CO).","can_select(S) :- Student(S), count(selects_primary(S, CO)) = 4, count(selects_alternate(S, CO)) = 2.","Student(?S) ∧ count(?selects_primary(S, CO)) ∧ count(?selects_alternate(S, CO)) => can_select(?S)"
This use case allows the Registrar to maintain student information in the registration system.,Registrar(R).,"Student(S), RegistrationSystem(RS).","has_access_to(R, RS) :- Registrar(R), RegistrationSystem(RS).","can_maintain(R, S, RS) :- Registrar(R), Student(S), RegistrationSystem(RS), has_access_to(R, RS).","Registrar(?R) ∧ Student(?S) ∧ RegistrationSystem(?RS) ∧ has_access_to(?R,?RS) => can_maintain(?R,?S,?RS)"
The Student verifies the deletion.,Student(S).,Deletion(DEL).,"can_verify(S, DEL) :- Student(S), Deletion(DEL).","verify(S, DEL) :- Student(S), Deletion(DEL), can_verify(S, DEL).","Student(?S) ∧ Deletion(?DEL) ∧ can_verify(?S,?DEL) => verify(?S,?DEL)"
"""If, in the Update a Professor  or Delete a Professor sub-flows, a professor with the specified id number does not exist, the system displays an error message.""",User(U).,Professor(P).,"has_id(P, ID) :- Professor(P).","can_update_or_delete(U, P) :- User(U), Professor(P), has_id(P, ID). display_error(U) :- User(U), not exists Professor(P) with has_id(P, ID).","User(?U) ∧ Professor(?P) ∧ has_id(?P,?ID). display_error(U) => can_update_or_delete(?U,?P)"
Professors will be able to access the system to sign up to teach courses as well as record grades.,Professor(P).,"Course(C), Grade(G).","teaches(P, C) :- Professor(P), Course(C).","can_access_system(P) :- Professor(P). can_sign_up_to_teach(P, C) :- Professor(P), Course(C). can_record_grade(P, G) :- Professor(P), Grade(G).","Professor(?P). can_sign_up_to_teach(P,?C) => can_access_system(?P)"
"""If, in the Update a Student  or Delete a Student  sub-flows, a student with the specified id number does not exist, the system displays an error message.""",User(U).,Student(S).,"has_id(S, ID) :- Student(S).","can_update_or_delete(U, S) :- User(U), Student(S), has_id(S, ID). display_error(U, S) :- User(U), Student(S), not has_id(S, ID).","User(?U) ∧ Student(?S) ∧ has_id(?S,?ID). display_error(U,?S) => can_update_or_delete(?U,?S)"
"""For each selected course offering on the schedule not already marked as “enrolled in”, the system verifies that the Student has the necessary prerequisites, that the course offering is open, and that there are no schedule conflicts.""",Student(S).,CourseOffering(CO).,"selected(S, CO) :- Student(S), CourseOffering(CO).
enrolled_in(S, CO) :- Student(S), CourseOffering(CO).
has_prerequisite(S, CO) :- Student(S), CourseOffering(CO).
open(CO) :- CourseOffering(CO).
conflict(S, CO) :- Student(S), CourseOffering(CO).","can_enroll(S, CO) :- Student(S), CourseOffering(CO), selected(S, CO), not enrolled_in(S, CO), has_prerequisite(S, CO), open(CO), not conflict(S, CO).","Student(?S) ∧ CourseOffering(?CO) ∧ selected(?S,?CO) ∧ not enrolled_in(?S,?CO) ∧ has_prerequisite(?S,?CO) ∧ open(?CO) ∧ not conflict(?S,?CO) => can_enroll(?S,?CO)"
"""If, in the Update a Schedule or Delete a Schedule sub-flows, the system is unable to retrieve the Student’s schedule, an error message is displayed.""","System(S), Student(ST).","Schedule(SCH), ErrorMessage(EM).","has_schedule(ST, SCH) :- Student(ST), Schedule(SCH).","display_error(S, ST, EM) :- System(S), Student(ST), ErrorMessage(EM), not has_schedule(ST, SCH).","System(?S) ∧ Student(?ST) ∧ ErrorMessage(?EM) ∧ not has_schedule(?ST,?SCH) => display_error(?S,?ST,?EM)"
The system requests that the Registrar enter the professor id,Registrar(R).,Professor(P).,"has_id(P, ID) :- Professor(P).","can_enter(R, P) :- Registrar(R), Professor(P).","Registrar(?R) ∧ Professor(?P) => can_enter(?R,?P)"
"""At the end of the semester, the student will be able to access the system to view an electronic report card.""",Student(S).,ReportCard(RC).,"has_report_card(S, RC) :- Student(S), ReportCard(RC).","can_view(S, RC) :- Student(S), ReportCard(RC), has_report_card(S, RC).","Student(?S) ∧ ReportCard(?RC) ∧ has_report_card(?S,?RC) => can_view(?S,?RC)"
The system requests that the Registrar enter the student id.,Registrar(R).,Student(S).,"has_id(S, ID) :- Student(S).","can_request_entry(R, S) :- Registrar(R), Student(S).","Registrar(?R) ∧ Student(?S) => can_request_entry(?R,?S)"
The system deletes the student from the system.,System(S).,Student(ST).,"enrolled_in(ST, S) :- Student(ST), System(S).","can_delete(S, ST) :- System(S), Student(ST), enrolled_in(ST, S).","System(?S) ∧ Student(?ST) ∧ enrolled_in(?ST,?S) => can_delete(?S,?ST)"
"""In addition, each student will indicate two alternative choices in case the student cannot be assigned to a primary selection.""",Student(S).,Choice(C).,"has_primary_choice(S, C) :- Student(S), Choice(C). has_alternative_choice(S, C) :- Student(S), Choice(C).","can_assign_alternative(S, C) :- Student(S), Choice(C), has_alternative_choice(S, C), not has_primary_choice(S, C).","Student(?S) ∧ Choice(?C) ∧ has_alternative_choice(?S,?C) ∧ not has_primary_choice(?S,?C) => can_assign_alternative(?S,?C)"
The system displays a list of course offerings the Professor taught in the previous semester.,Professor(P).,CourseOffering(C).,"taught_in_previous_semester(P, C) :- Professor(P), CourseOffering(C).","can_view_course_list(P, C) :- Professor(P), CourseOffering(C), taught_in_previous_semester(P, C).","Professor(?P) ∧ CourseOffering(?C) ∧ taught_in_previous_semester(?P,?C) => can_view_course_list(?P,?C)"
"""If there is no conflict, the system updates the course offering information for each offering the professor selects (i.e., records the professor as the instructor for the course offering).""",Professor(P).,CourseOffering(CO).,"has_conflict(P, CO) :- Professor(P), CourseOffering(CO).","can_update_offering(P, CO) :- Professor(P), CourseOffering(CO), not has_conflict(P, CO).","Professor(?P) ∧ CourseOffering(?CO) ∧ not has_conflict(?P,?CO) => can_update_offering(?P,?CO)"
"""If, in the Basic Flow, the professor is not eligible to teach any course offerings in the upcoming semester, the system will display an error message.""",Professor(P).,CourseOffering(CO).,"eligible_to_teach(P, CO) :- Professor(P), CourseOffering(CO).","display_error(P) :- Professor(P), not eligible_to_teach(P, _).","Professor(?P) ∧ not eligible_to_teach(?P,?_) => display_error(?P)"
The system requests that the Registrar enter the professor information.,Registrar(R).,ProfessorInfo(PI).,"has_access(R, PI) :- Registrar(R), ProfessorInfo(PI).","can_enter(R, PI) :- Registrar(R), ProfessorInfo(PI), has_access(R, PI).","Registrar(?R) ∧ ProfessorInfo(?PI) ∧ has_access(?R,?PI) => can_enter(?R,?PI)"
This use case allows a Professor to submit student grades for one or more classes completed in the previous semester.,Professor(P).,"Student(S), Class(C).","teaches(P, C) :- Professor(P), Class(C).
completed(S, C) :- Student(S), Class(C).","can_submit_grade(P, S, C) :- Professor(P), Student(S), Class(C), teaches(P, C), completed(S, C).","Professor(?P) ∧ Student(?S) ∧ Class(?C) ∧ teaches(?P,?C) ∧ completed(?S,?C) => can_submit_grade(?P,?S,?C)"
"""If the Professor wishes to skip a particular student, the grade information can be left blank and filled in at a later time.""",Professor(P).,"Student(S), Grade(G).","teaches(P, S) :- Professor(P), Student(S).","can_skip_grade(P, S) :- Professor(P), Student(S), teaches(P, S).","Professor(?P) ∧ Student(?S) ∧ teaches(?P,?S) => can_skip_grade(?P,?S)"
"""Once the registration process is completed for a student, the registration system sends information to the billing system so the student can be billed for the semester.""","Student(S), RegistrationSystem(RS), BillingSystem(BS).",Semester(SEM).,"registered_for(S, SEM) :- Student(S), Semester(SEM).","can_bill(BS, S, SEM) :- BillingSystem(BS), Student(S), Semester(SEM), registered_for(S, SEM).","BillingSystem(?BS) ∧ Student(?S) ∧ Semester(?SEM) ∧ registered_for(?S,?SEM) => can_bill(?BS,?S,?SEM)"
The Professor selects a course offering.,Professor(P).,CourseOffering(CO).,"can_select(P, CO) :- Professor(P), CourseOffering(CO).","selects(P, CO) :- can_select(P, CO).","can_select(?P,?CO) => selects(?P,?CO)"
The system also retrieves and displays the list of courses the professor has previously selected to teach.,Professor(P).,Course(C).,"teaches(P, C) :- Professor(P), Course(C).","can_view_courses(P, C) :- Professor(P), Course(C), teaches(P, C).","Professor(?P) ∧ Course(?C) ∧ teaches(?P,?C) => can_view_courses(?P,?C)"
"""If, in the Submit Schedule sub-flow, the system determines that the Student has not satisfied the necessary prerequisites, or that the selected course offering is full, or that there are schedule conflicts, an error message is displayed.""",Student(S).,CourseOffering(CO).,"has_prerequisite(S, CO) :- Student(S), CourseOffering(CO).
full_course(CO) :- CourseOffering(CO).
schedule_conflict(S, CO) :- Student(S), CourseOffering(CO).","can_submit_schedule(S, CO) :- Student(S), CourseOffering(CO), has_prerequisite(S, CO), not full_course(CO), not schedule_conflict(S, CO).
display_error(S, CO) :- Student(S), CourseOffering(CO), not can_submit_schedule(S, CO).","Student(?S) ∧ CourseOffering(?CO) ∧ has_prerequisite(?S,?CO) ∧ not full_course(?CO) ∧ not schedule_conflict(?S,?CO). display_error(S,?CO) => can_submit_schedule(?S,?CO)"
The system retrieves and displays the student information.,User(U).,StudentInfo(SI).,"has_access(U, SI) :- User(U), StudentInfo(SI).","can_retrieve_display(U, SI) :- User(U), StudentInfo(SI), has_access(U, SI).","User(?U) ∧ StudentInfo(?SI) ∧ has_access(?U,?SI) => can_retrieve_display(?U,?SI)"
"""If, in the Delete A Student  sub-flow, the Registrar decides not to delete the student, the delete is cancelled and the Basic Flow is re-started at the beginning.""",Registrar(R).,"Student(S), Flow(F).","in_subflow(R, S, 'Delete A Student') :- Registrar(R), Student(S).","cancel_delete(R, S) :- Registrar(R), Student(S), in_subflow(R, S, 'Delete A Student'), not decides_to_delete(R, S). restart_basic_flow(R, F) :- Registrar(R), Flow(F), cancel_delete(R, S).","Registrar(?R) ∧ Student(?S) ∧ in_subflow(?R,?S,'Delete A Student') ∧ not decides_to_delete(?R,?S). restart_basic_flow(R,?F) => cancel_delete(?R,?S)"
The system displays each student and any grade that was previously assigned for the offering.,User(U).,"Student(S), Offering(O), Grade(G).","enrolled_in(S, O) :- Student(S), Offering(O). assigned_grade(S, O, G) :- Student(S), Offering(O), Grade(G).","can_view_grade(U, S, O, G) :- User(U), Student(S), Offering(O), Grade(G), enrolled_in(S, O), assigned_grade(S, O, G).","User(?U) ∧ Student(?S) ∧ Offering(?O) ∧ Grade(?G) ∧ enrolled_in(?S,?O) ∧ assigned_grade(?S,?O,?G) => can_view_grade(?U,?S,?O,?G)"
"""If the use case was successful, student grades for a course offering are updated.""","Student(S), Instructor(I).","CourseOffering(CO), Grade(G).","enrolled_in(S, CO) :- Student(S), CourseOffering(CO).","can_update_grade(I, S, CO, G) :- Instructor(I), Student(S), CourseOffering(CO), Grade(G), enrolled_in(S, CO), use_case_successful().","Instructor(?I) ∧ Student(?S) ∧ CourseOffering(?CO) ∧ Grade(?G) ∧ enrolled_in(?S,?CO) ∧ use_case_successful() => can_update_grade(?I,?S,?CO,?G)"
The system removes the professor from teaching the de-selected course offerings.,"System(S), Professor(P).",CourseOffering(CO).,"teaches(P, CO) :- Professor(P), CourseOffering(CO).","remove_teaching(S, P, CO) :- System(S), Professor(P), CourseOffering(CO), teaches(P, CO).","System(?S) ∧ Professor(?P) ∧ CourseOffering(?CO) ∧ teaches(?P,?CO) => remove_teaching(?S,?P,?CO)"
The system prompts the Registrar to confirm the deletion of the professor.,"Registrar(R), System(S).",Professor(P).,"is_prompted_to_confirm_deletion(R, P) :- Registrar(R), Professor(P).","can_delete(R, P) :- Registrar(R), Professor(P), is_prompted_to_confirm_deletion(R, P).","Registrar(?R) ∧ Professor(?P) ∧ is_prompted_to_confirm_deletion(?R,?P) => can_delete(?R,?P)"
"""If the use case was successful, the student schedule is created, updated, or deleted.""","Student(S), Administrator(A).",Schedule(SC).,"has_schedule(S, SC) :- Student(S), Schedule(SC).","can_modify_schedule(A, S, SC) :- Administrator(A), Student(S), Schedule(SC), use_case_successful().","Administrator(?A) ∧ Student(?S) ∧ Schedule(?SC) ∧ use_case_successful() => can_modify_schedule(?A,?S,?SC)"
The system provides the Registrar with the new professor id.,"Registrar(R), System(S).",ProfessorID(PID).,"provides(S, R, PID) :- System(S), Registrar(R), ProfessorID(PID).","can_provide(S, R, PID) :- System(S), Registrar(R), ProfessorID(PID), provides(S, R, PID).","System(?S) ∧ Registrar(?R) ∧ ProfessorID(?PID) ∧ provides(?S,?R,?PID) => can_provide(?S,?R,?PID)"
The system provides the Registrar with the new student id.,"Registrar(R), System(S).",StudentID(ID).,"provides(S, R, ID) :- System(S), Registrar(R), StudentID(ID).","can_access(R, ID) :- Registrar(R), StudentID(ID), provides(S, R, ID).","Registrar(?R) ∧ StudentID(?ID) ∧ provides(?S,?R,?ID) => can_access(?R,?ID)"
The Professor may also change the grade for a student by entering a new grade.,Professor(P).,"Student(S), Grade(G).","has_grade(S, G) :- Student(S), Grade(G).","can_change_grade(P, S, G) :- Professor(P), Student(S), Grade(G).","Professor(?P) ∧ Student(?S) ∧ Grade(?G) => can_change_grade(?P,?S,?G)"
The Student may update the course selections on the current selection by deleting and adding new course offerings.,Student(S).,CourseOffering(CO).,"has_selection(S, CO) :- Student(S), CourseOffering(CO).","can_update(S, CO) :- Student(S), CourseOffering(CO), has_selection(S, CO).","Student(?S) ∧ CourseOffering(?CO) ∧ has_selection(?S,?CO) => can_update(?S,?CO)"
This use case allows a Student to register for course offerings in the current semester.,Student(S).,CourseOffering(CO).,is_current_semester(CO) :- CourseOffering(CO).,"can_register(S, CO) :- Student(S), CourseOffering(CO), is_current_semester(CO).","Student(?S) ∧ CourseOffering(?CO) ∧ is_current_semester(?CO) => can_register(?S,?CO)"
"""Once the Registrar updates the necessary information, the system updates the student information.""","Registrar(R), System(S).","Student(ST), Information(I).","has_updated(R, I) :- Registrar(R), Information(I).","can_update(S, ST, I) :- System(S), Student(ST), Information(I), has_updated(R, I).","System(?S) ∧ Student(?ST) ∧ Information(?I) ∧ has_updated(?R,?I) => can_update(?S,?ST,?I)"
Only the Registrar is allowed to change any student information.,Registrar(R).,"Student(S), StudentInfo(I).","has_info(S, I) :- Student(S), StudentInfo(I).","can_change(R, S, I) :- Registrar(R), Student(S), StudentInfo(I), has_info(S, I).","Registrar(?R) ∧ Student(?S) ∧ StudentInfo(?I) ∧ has_info(?S,?I) => can_change(?R,?S,?I)"
The Registrar verifies the deletion.,Registrar(R).,Deletion(D).,"verifies(R, D) :- Registrar(R), Deletion(D).","can_verify(R, D) :- Registrar(R), Deletion(D).","Registrar(?R) ∧ Deletion(?D) => can_verify(?R,?D)"
The system deletes the professor from the system.,System(S).,Professor(P).,is_deleted(P) :- Professor(P).,"delete_professor(S, P) :- System(S), Professor(P), is_deleted(P).","System(?S) ∧ Professor(?P) ∧ is_deleted(?P) => delete_professor(?S,?P)"
"""For each semester, there is a period of time that students can change their schedule.""","Student(S), Semester(SM).",Schedule(SC).,"enrolled_in(S, SM) :- Student(S), Semester(SM).","can_change_schedule(S, SM, SC) :- Student(S), Semester(SM), Schedule(SC), enrolled_in(S, SM).","Student(?S) ∧ Semester(?SM) ∧ Schedule(?SC) ∧ enrolled_in(?S,?SM) => can_change_schedule(?S,?SM,?SC)"
"""Once the student has made his or her selections, the system updates the schedule for the Student using the selected course offerings.""",Student(S).,CourseOffering(CO).,"has_selection(S, CO) :- Student(S), CourseOffering(CO).","can_update_schedule(S, CO) :- Student(S), CourseOffering(CO), has_selection(S, CO).","Student(?S) ∧ CourseOffering(?CO) ∧ has_selection(?S,?CO) => can_update_schedule(?S,?CO)"
This use case allows a Student to view his or her report card for the previously completed semester.,Student(S).,"ReportCard(R), Semester(Sem).","completed_semester(S, Sem) :- Student(S), Semester(Sem).","can_view(S, R) :- Student(S), ReportCard(R), completed_semester(S, Sem).","Student(?S) ∧ ReportCard(?R) ∧ completed_semester(?S,?Sem) => can_view(?S,?R)"
The student is added to the system.,SystemAdmin(A).,Student(S).,enrolled(S) :- Student(S).,"add_student(A, S) :- SystemAdmin(A), Student(S), not enrolled(S).","SystemAdmin(?A) ∧ Student(?S) ∧ not enrolled(?S) => add_student(?A,?S)"
This use case allows the Registrar to maintain professor information in the registration system.,Registrar(R).,"Professor(P), RegistrationSystem(S).","maintains(R, P, S) :- Registrar(R), Professor(P), RegistrationSystem(S).","can_maintain(R, P, S) :- Registrar(R), Professor(P), RegistrationSystem(S), maintains(R, P, S).","Registrar(?R) ∧ Professor(?P) ∧ RegistrationSystem(?S) ∧ maintains(?R,?P,?S) => can_maintain(?R,?P,?S)"
The system requests that the Registrar enter the student information.,Registrar(R).,StudentInfo(SI).,"has_access(R, SI) :- Registrar(R), StudentInfo(SI).","can_enter(R, SI) :- Registrar(R), StudentInfo(SI), has_access(R, SI).","Registrar(?R) ∧ StudentInfo(?SI) ∧ has_access(?R,?SI) => can_enter(?R,?SI)"
"""If so, the system commits the course offering for each schedule that contains it.""",System(S).,"CourseOffering(CO), Schedule(SCH).","contains(SCH, CO) :- Schedule(SCH), CourseOffering(CO).","commits(S, CO) :- System(S), CourseOffering(CO), Schedule(SCH), contains(SCH, CO).","System(?S) ∧ CourseOffering(?CO) ∧ Schedule(?SCH) ∧ contains(?SCH,?CO) => commits(?S,?CO)"
"""Once the Registrar updates the necessary information, the system updates the professor record.""","Registrar(R), System(S).",ProfessorRecord(PR).,"has_updated(R, PR) :- Registrar(R), ProfessorRecord(PR).","can_update(S, PR) :- System(S), ProfessorRecord(PR), has_updated(R, PR).","System(?S) ∧ ProfessorRecord(?PR) ∧ has_updated(?R,?PR) => can_update(?S,?PR)"
The Student can also update or delete course selections if changes are made within the add or drop period at the beginning of the semester.,Student(S).,Course(C).,"enrolled_in(S, C) :- Student(S), Course(C).","can_update(S, C) :- Student(S), Course(C), enrolled_in(S, C), within_add_drop_period(). can_delete(S, C) :- Student(S), Course(C), enrolled_in(S, C), within_add_drop_period().","Student(?S) ∧ Course(?C) ∧ enrolled_in(?S,?C) ∧ within_add_drop_period(?). can_delete(S,?C) => can_update(?S,?C)"
Professors cannot change the course offerings they teach after registration for the current semester has been closed.,Professor(P).,"Course(C), Semester(S).","teaches(P, C, S) :- Professor(P), Course(C), Semester(S). registration_closed(S) :- Semester(S).","cannot_change_course(P, C, S) :- Professor(P), Course(C), Semester(S), teaches(P, C, S), registration_closed(S).","Professor(?P) ∧ Course(?C) ∧ Semester(?S) ∧ teaches(?P,?C,?S) ∧ registration_closed(?S) => cannot_change_course(?P,?C,?S)"
"""At the beginning of each semester, students may request a course catalogue containing a list of course offerings for the semester.""",Student(S).,"CourseCatalogue(CC), Course(C).","contains(CC, C) :- CourseCatalogue(CC), Course(C).","can_request(S, CC) :- Student(S), CourseCatalogue(CC).","Student(?S) ∧ CourseCatalogue(?CC) => can_request(?S,?CC)"
"""If, in the Basic Flow, the system cannot find any grade information from the previous semester for the Student, a message is displayed.""",Student(S).,Message(M).,has_previous_grade(S) :- Student(S).,"display_message(S, M) :- Student(S), Message(M), not has_previous_grade(S).","Student(?S) ∧ Message(?M) ∧ not has_previous_grade(?S) => display_message(?S,?M)"
"""If the system is unable to communicate with the Course Catalog System, the system will display an error message to the Student.""","System(S), Student(ST).","CourseCatalog(CC), ErrorMessage(EM).","cannot_communicate(S, CC) :- System(S), CourseCatalog(CC).","display_error(S, ST, EM) :- System(S), Student(ST), ErrorMessage(EM), cannot_communicate(S, CC).","System(?S) ∧ Student(?ST) ∧ ErrorMessage(?EM) ∧ cannot_communicate(?S,?CC) => display_error(?S,?ST,?EM)"
The system requests that the Registrar enter the professor id.,Registrar(R).,Professor(P).,"has_id(P, ID) :- Professor(P).","can_enter(R, P) :- Registrar(R), Professor(P).","Registrar(?R) ∧ Professor(?P) => can_enter(?R,?P)"
"""In addition, the professors will be able to record the grades for the students in each class.""","Professor(P), Student(S).","Class(C), Grade(G).","enrolled_in(S, C) :- Student(S), Class(C). teaches(P, C) :- Professor(P), Class(C).","can_record_grade(P, S, C, G) :- Professor(P), Student(S), Class(C), Grade(G), teaches(P, C), enrolled_in(S, C).","Professor(?P) ∧ Student(?S) ∧ Class(?C) ∧ Grade(?G) ∧ teaches(?P,?C) ∧ enrolled_in(?S,?C) => can_record_grade(?P,?S,?C,?G)"
The system retrieves a list of all students who were registered for the course offering.,System(S).,"Student(ST), CourseOffering(CO).","registered_for(ST, CO) :- Student(ST), CourseOffering(CO).","can_retrieve(S, ST, CO) :- System(S), Student(ST), CourseOffering(CO), registered_for(ST, CO).","System(?S) ∧ Student(?ST) ∧ CourseOffering(?CO) ∧ registered_for(?ST,?CO) => can_retrieve(?S,?ST,?CO)"
"""This use case starts when the Registrar wishes to add, change, possibly and possibly delete student information in the system.""",Registrar(R).,StudentInfo(SI).,"has_permission(R, SI) :- Registrar(R), StudentInfo(SI).","can_modify(R, SI) :- Registrar(R), StudentInfo(SI), has_permission(R, SI).","Registrar(?R) ∧ StudentInfo(?SI) ∧ has_permission(?R,?SI) => can_modify(?R,?SI)"
The Registrar enters the professor id.,Registrar(R).,Professor(P).,"enters_id(R, P) :- Registrar(R), Professor(P).","can_enter_id(R, P) :- Registrar(R), Professor(P), enters_id(R, P).","Registrar(?R) ∧ Professor(?P) ∧ enters_id(?R,?P) => can_enter_id(?R,?P)"
This use case allows a Registrar to close the registration process.,Registrar(R).,RegistrationProcess(P).,"can_close(R, P) :- Registrar(R), RegistrationProcess(P).","close_registration(R, P) :- Registrar(R), RegistrationProcess(P), can_close(R, P).","Registrar(?R) ∧ RegistrationProcess(?P) ∧ can_close(?R,?P) => close_registration(?R,?P)"
"""If the use case was successful, the professor information is added, updated, or deleted from the system.""",User(U).,Professor(P).,"successful_use_case(U, P) :- User(U), Professor(P).","add_professor_info(U, P) :- User(U), Professor(P), successful_use_case(U, P). update_professor_info(U, P) :- User(U), Professor(P), successful_use_case(U, P). delete_professor_info(U, P) :- User(U), Professor(P), successful_use_case(U, P).","User(?U) ∧ Professor(?P) ∧ successful_use_case(?U,?P). update_professor_info(U,?P) => add_professor_info(?U,?P)"
The system retrieves and displays the list of course offerings the professor is eligible to teach for the current semester.,Professor(P).,"CourseOffering(CO), Semester(S).","eligible_to_teach(P, CO) :- Professor(P), CourseOffering(CO), Semester(S), current_semester(S).","can_retrieve_display(P, CO) :- Professor(P), CourseOffering(CO), eligible_to_teach(P, CO).","Professor(?P) ∧ CourseOffering(?CO) ∧ eligible_to_teach(?P,?CO) => can_retrieve_display(?P,?CO)"
The system requests that the Registrar enter the student id,Registrar(R).,Student(S).,"has_student_id(S, ID) :- Student(S).","can_enter_student_id(R, S, ID) :- Registrar(R), Student(S), has_student_id(S, ID).","Registrar(?R) ∧ Student(?S) ∧ has_student_id(?S,?ID) => can_enter_student_id(?R,?S,?ID)"
The system retrieves and displays the grade information for each of the course offerings the Student completed during the previous semester.,Student(S).,"CourseOffering(C), GradeInfo(G).","completed_course(S, C) :- Student(S), CourseOffering(C).","can_retrieve_grade(S, C, G) :- Student(S), CourseOffering(C), GradeInfo(G), completed_course(S, C).","Student(?S) ∧ CourseOffering(?C) ∧ GradeInfo(?G) ∧ completed_course(?S,?C) => can_retrieve_grade(?S,?C,?G)"
"""The system verifies that the selected offerings do not conflict (i.e., have the same dates and times) with each other or any course offerings that the professor has previously signed up to teach.""",Professor(P).,"CourseOffering(O), SelectedOffering(S).","signed_up(P, O) :- Professor(P), CourseOffering(O).
conflict(O1, O2) :- CourseOffering(O1), CourseOffering(O2), same_date_time(O1, O2).","can_select(P, S) :- Professor(P), SelectedOffering(S), CourseOffering(O), not conflict(S, O), not signed_up(P, O).","Professor(?P) ∧ SelectedOffering(?S) ∧ CourseOffering(?O) ∧ not conflict(?S,?O) ∧ not signed_up(?P,?O) => can_select(?P,?S)"
The Student selects the course offerings to add from the list of available course offerings.,Student(S).,CourseOffering(CO).,available(CO) :- CourseOffering(CO).,"can_select(S, CO) :- Student(S), CourseOffering(CO), available(CO).","Student(?S) ∧ CourseOffering(?CO) ∧ available(?CO) => can_select(?S,?CO)"
The system will also indicate which are the conflicting courses.,User(U).,Course(C).,"conflicts_with(C1, C2) :- Course(C1), Course(C2).","indicate_conflicts(U, C1, C2) :- User(U), Course(C1), Course(C2), conflicts_with(C1, C2).","User(?U) ∧ Course(?C1) ∧ Course(?C2) ∧ conflicts_with(?C1,?C2) => indicate_conflicts(?U,?C1,?C2)"
This use case allows a Professor to select the course offerings from the course catalog for the courses that he or she is eligible for and wishes to teach in the upcoming semester.,Professor(P).,"Course(C), CourseOffering(O).","eligible_for(P, C) :- Professor(P), Course(C).
wishes_to_teach(P, C) :- Professor(P), Course(C).
part_of_catalog(C) :- Course(C).
upcoming_semester(O) :- CourseOffering(O).","can_select(P, O) :- Professor(P), CourseOffering(O), Course(C), eligible_for(P, C), wishes_to_teach(P, C), part_of_catalog(C), upcoming_semester(O).","Professor(?P) ∧ CourseOffering(?O) ∧ Course(?C) ∧ eligible_for(?P,?C) ∧ wishes_to_teach(?P,?C) ∧ part_of_catalog(?C) ∧ upcoming_semester(?O) => can_select(?P,?O)"
The system then adds the Student to the selected course offering.,"System(S), Student(ST).",CourseOffering(CO).,"enrolled_in(ST, CO) :- Student(ST), CourseOffering(CO).","can_add(S, ST, CO) :- System(S), Student(ST), CourseOffering(CO).","System(?S) ∧ Student(?ST) ∧ CourseOffering(?CO) => can_add(?S,?ST,?CO)"
"""If the schedule contains “enrolled in” course offerings, the Student must be removed from the course offering.""",Student(S).,CourseOffering(CO).,"enrolled_in(S, CO) :- Student(S), CourseOffering(CO).","remove_from_course(S, CO) :- Student(S), CourseOffering(CO), enrolled_in(S, CO).","Student(?S) ∧ CourseOffering(?CO) ∧ enrolled_in(?S,?CO) => remove_from_course(?S,?CO)"
"""This includes adding, modifying, and deleting professors from the system.""",Administrator(A).,Professor(P).,is_administrator(A) :- Administrator(A).,"can_add(A, P) :- Administrator(A), Professor(P). can_modify(A, P) :- Administrator(A), Professor(P). can_delete(A, P) :- Administrator(A), Professor(P).","Administrator(?A) ∧ Professor(?P). can_modify(A,?P) => can_add(?A,?P)"
The Registrar makes the desired changes to the professor information.,Registrar(R).,ProfessorInfo(PI).,,"can_modify(R, PI) :- Registrar(R), ProfessorInfo(PI).","Registrar(?R) ∧ ProfessorInfo(?PI) => can_modify(?R,?PI)"
Professors must be able to access the on-line system to indicate which courses they will be teaching.,Professor(P).,"Course(C), System(S).","teaches(P, C) :- Professor(P), Course(C).","can_access(P, S) :- Professor(P), System(S). can_indicate(P, C) :- Professor(P), Course(C), teaches(P, C).","Professor(?P) ∧ System(?S). can_indicate(P,?C) => can_access(?P,?S)"
"""If a course fills up during the actual registration process, the student must be notified of the change before submitting the schedule for processing.""",Student(S).,Course(C).,fills_up(C) :- Course(C).,"must_notify(S, C) :- Student(S), Course(C), fills_up(C).","Student(?S) ∧ Course(?C) ∧ fills_up(?C) => must_notify(?S,?C)"
Students cannot register for course offerings after registration for the current semester has been closed.,Student(S).,CourseOffering(CO).,registration_closed(CO) :- CourseOffering(CO).,"can_register(S, CO) :- Student(S), CourseOffering(CO), not registration_closed(CO).","Student(?S) ∧ CourseOffering(?CO) ∧ not registration_closed(?CO) => can_register(?S,?CO)"
The system prompts the Registrar to confirm the deletion of the student.,"Registrar(R), System(S).",Student(ST).,"is_registrar_for(R, ST) :- Registrar(R), Student(ST).","prompt_to_confirm_deletion(S, R, ST) :- System(S), Registrar(R), Student(ST), is_registrar_for(R, ST).","System(?S) ∧ Registrar(?R) ∧ Student(?ST) ∧ is_registrar_for(?R,?ST) => prompt_to_confirm_deletion(?S,?R,?ST)"
The system retrieves and displays the professor information.,User(U).,Professor(P).,"has_access(U, P) :- User(U), Professor(P).","can_retrieve_display(U, P) :- User(U), Professor(P), has_access(U, P).","User(?U) ∧ Professor(?P) ∧ has_access(?U,?P) => can_retrieve_display(?U,?P)"
Students must be able to access the system during this time to add or drop courses.,Student(S).,"System(SY), Course(C).","enrolled_in(S, C) :- Student(S), Course(C).","can_access(S, SY) :- Student(S), System(SY), during_time(T). can_add_course(S, C) :- Student(S), Course(C), can_access(S, SY). can_drop_course(S, C) :- Student(S), Course(C), can_access(S, SY), enrolled_in(S, C).","Student(?S) ∧ System(?SY) ∧ during_time(?T). can_add_course(S,?C) => can_access(?S,?SY)"
The system deletes the Schedule.,System(S).,Schedule(SC).,,"can_delete(S, SC) :- System(S), Schedule(SC).","System(?S) ∧ Schedule(?SC) => can_delete(?S,?SC)"
"""For each course offering, the system closes all course offerings.""",System(S).,CourseOffering(CO).,,"can_close(S, CO) :- System(S), CourseOffering(CO).","System(?S) ∧ CourseOffering(?CO) => can_close(?S,?CO)"
The Close Registration processing cannot be performed if registration is in progress.,User(U).,Registration(R).,in_progress(R) :- Registration(R).,"can_close_registration(U, R) :- User(U), Registration(R), not in_progress(R).","User(?U) ∧ Registration(?R) ∧ not in_progress(?R) => can_close_registration(?U,?R)"
The Registrar makes the desired changes to the student information.,Registrar(R).,"Student(S), Information(I).","has_information(S, I) :- Student(S), Information(I).","can_change(R, S, I) :- Registrar(R), Student(S), Information(I), has_information(S, I).","Registrar(?R) ∧ Student(?S) ∧ Information(?I) ∧ has_information(?S,?I) => can_change(?R,?S,?I)"
The Registrar enters the student id.,Registrar(R).,Student(S).,"has_student_id(S, ID) :- Student(S).","can_enter(R, S, ID) :- Registrar(R), Student(S), has_student_id(S, ID).","Registrar(?R) ∧ Student(?S) ∧ has_student_id(?S,?ID) => can_enter(?R,?S,?ID)"
"""The Billing System will send the bill to the students, which will include a copy of their final schedule.""","BillingSystem(BS), Student(S).","Bill(B), FinalSchedule(FS).","has_final_schedule(S, FS) :- Student(S), FinalSchedule(FS).","can_send_bill(BS, S, B, FS) :- BillingSystem(BS), Student(S), Bill(B), FinalSchedule(FS), has_final_schedule(S, FS).","BillingSystem(?BS) ∧ Student(?S) ∧ Bill(?B) ∧ FinalSchedule(?FS) ∧ has_final_schedule(?S,?FS) => can_send_bill(?BS,?S,?B,?FS)"
"""Once the student has made his or her selections, the system creates a schedule for the Student containing the selected course offerings.""",Student(S).,CourseOffering(CO).,"has_selection(S, CO) :- Student(S), CourseOffering(CO).","can_create_schedule(S, CO) :- Student(S), CourseOffering(CO), has_selection(S, CO).","Student(?S) ∧ CourseOffering(?CO) ∧ has_selection(?S,?CO) => can_create_schedule(?S,?CO)"
"""If the course offerings do not have at least three students at this point (some may have been added as a result of leveling), then the system cancels the course offering.""",System(S).,CourseOffering(CO).,"has_student(CO, St) :- CourseOffering(CO), Student(St).","can_cancel(S, CO) :- System(S), CourseOffering(CO), count_students(CO, Count), Count < 3.","System(?S) ∧ CourseOffering(?CO) ∧ count_students(?CO,?Count) ∧ ?Count < 3 => can_cancel(?S,?CO)"
"""If the systems find a schedule conflict when trying to establish the course offerings the Professor should take, the system will display an error message indicating that a schedule conflict has occurred.""",Professor(P).,"Course(C), Schedule(S).","has_schedule_conflict(P, C) :- Professor(P), Course(C), Schedule(S).","display_error(P) :- Professor(P), Course(C), has_schedule_conflict(P, C).","Professor(?P) ∧ Course(?C) ∧ has_schedule_conflict(?P,?C) => display_error(?P)"
"""If the use case was successful, the student information is added, updated, or deleted from the system.""",User(U).,StudentInfo(SI).,"has_access(U, SI) :- User(U), StudentInfo(SI).","can_modify(U, SI) :- User(U), StudentInfo(SI), has_access(U, SI), use_case_successful(U, SI).","User(?U) ∧ StudentInfo(?SI) ∧ has_access(?U,?SI) ∧ use_case_successful(?U,?SI) => can_modify(?U,?SI)"
"""If, in the Basic Flow, the Professor did not teach any course offerings in the previous semester, the system will display an error message.""",Professor(P).,"Semester(S), CourseOffering(C).","previous_semester(S) :- Semester(S). taught(P, C, S) :- Professor(P), CourseOffering(C), Semester(S).","display_error(P) :- Professor(P), previous_semester(S), not taught(P, _, S).","Professor(?P) ∧ previous_semester(?S) ∧ not taught(?P,?_,?S) => display_error(?P)"
"""If, in the Basic Flow, the actor enters an invalid name possibly and possibly password, the system displays an error message.""",Actor(A).,"System(S), ErrorMessage(E).",enters_invalid_name(A) :- Actor(A). enters_invalid_password(A) :- Actor(A).,"displays_error_message(S, A, E) :- System(S), Actor(A), ErrorMessage(E), enters_invalid_name(A), enters_invalid_password(A).","System(?S) ∧ Actor(?A) ∧ ErrorMessage(?E) ∧ enters_invalid_name(?A) ∧ enters_invalid_password(?A) => displays_error_message(?S,?A,?E)"
The actor enters his or her name and password.,Actor(A).,"Name(N), Password(PW).","enters_name(A, N) :- Actor(A), Name(N). enters_password(A, PW) :- Actor(A), Password(PW).","can_authenticate(A) :- Actor(A), enters_name(A, N), enters_password(A, PW).","Actor(?A) ∧ enters_name(?A,?N) ∧ enters_password(?A,?PW) => can_authenticate(?A)"
"""If the system is unable to communicate with the Billing System, the system will attempt to re-send the request after a specified period.""",System(S).,"BillingSystem(B), Request(R).","unable_to_communicate(S, B) :- System(S), BillingSystem(B).","resend_request(S, R) :- System(S), Request(R), BillingSystem(B), unable_to_communicate(S, B).","System(?S) ∧ Request(?R) ∧ BillingSystem(?B) ∧ unable_to_communicate(?S,?B) => resend_request(?S,?R)"
"The Professor can either resolve the schedule conflict (i.e., by canceling his selection to teach one of the course offerings)",Professor(P).,CourseOffering(C).,"teaches(P, C) :- Professor(P), CourseOffering(C).","can_resolve_conflict(P) :- Professor(P), teaches(P, C1), teaches(P, C2), C1 != C2, not (conflict_resolved(P)).","Professor(?P) ∧ teaches(?P,?C1) ∧ teaches(?P,?C2) ∧ ?C1 != ?C2 ∧ (conflict_resolved(?P)) => can_resolve_conflict(?P)"
The Professor can cancel the operation,Professor(P).,Operation(O).,"can_cancel(P, O) :- Professor(P), Operation(O).","can_cancel(P, O) :- Professor(P), Operation(O).","Professor(?P) ∧ Operation(?O) => can_cancel(?P,?O)"
any selections will be lost,User(U).,Selection(S).,"has_selection(U, S) :- User(U), Selection(S).","lose_selection(U, S) :- User(U), Selection(S), has_selection(U, S).","User(?U) ∧ Selection(?S) ∧ has_selection(?U,?S) => lose_selection(?U,?S)"
the use case ends.,,,,,"Professor(?P) ∧ Student(?S) ∧ Grade(?G) ∧ on_list(?S) => can_enter_grade(?P,?S,?G)"
"For each student on the list, the Professor enters a grade: A, B, C, D, F, or I.",Professor(P).,"Student(S), Grade(G).",on_list(S) :- Student(S).,"can_enter_grade(P, S, G) :- Professor(P), Student(S), Grade(G), on_list(S).","System(?S) ∧ Student(?ST) ∧ CourseOffering(?CO) ∧ Grade(?G) ∧ enrolled_in(?ST,?CO) => can_record_grade(?S,?ST,?CO,?G)"
The system records the student’s grade for the course offering.,"System(S), Student(ST).","CourseOffering(CO), Grade(G).","enrolled_in(ST, CO) :- Student(ST), CourseOffering(CO).","can_record_grade(S, ST, CO, G) :- System(S), Student(ST), CourseOffering(CO), Grade(G), enrolled_in(ST, CO).","Registrar(?R) ∧ IDNumber(?ID) => can_enter(?R,?ID)"
The Registrar can then enter a different id number,Registrar(R).,IDNumber(ID).,,"can_enter(R, ID) :- Registrar(R), IDNumber(ID).","Registrar(?R) ∧ Operation(?O) => can_cancel(?R,?O)"
"The Registrar can cancel the operation, at which point the use case ends.",Registrar(R).,Operation(O).,,"can_cancel(R, O) :- Registrar(R), Operation(O).","Student(?S) ∧ CourseOffering(?CO) ∧ not enrolled_in(?S,?CO) => can_select(?S,?CO)"
The Student can either select a different course offering and,Student(S).,CourseOffering(CO).,"enrolled_in(S, CO) :- Student(S), CourseOffering(CO).","can_select(S, CO) :- Student(S), CourseOffering(CO), not enrolled_in(S, CO).","Student(?S) ∧ Schedule(?SC) ∧ owns_schedule(?S,?SC) => can_save(?S,?SC)"
the use case continues,,,,,"Student(?S) ∧ Operation(?O) => can_cancel(?S,?O)"
"The Student save the schedule, as is (see Save a Schedule subflow)",Student(S).,Schedule(SC).,"owns_schedule(S, SC) :- Student(S), Schedule(SC).","can_save(S, SC) :- Student(S), Schedule(SC), owns_schedule(S, SC).","Registrar(?R) ∧ Student(?S) ∧ not decides_not_to_delete(?R,?S) => can_delete(?R,?S)"
The Student can cancel the operation,Student(S).,Operation(O).,,"can_cancel(S, O) :- Student(S), Operation(O).","User(?U) ∧ Resource(?R) ∧ has_permission(?U,?R,?delete) => can_cancel_delete(?U,?R)"
"If, in the Delete A Student sub-flow, the Registrar decides not to delete the student,",Registrar(R).,Student(S).,"decides_not_to_delete(R, S) :- Registrar(R), Student(S).","can_delete(R, S) :- Registrar(R), Student(S), not decides_not_to_delete(R, S).","User(?U) ∧ Flow(?F) ∧ can_restart(?U,?F) => restart_flow(?U,?F)"
the delete is cancelled,User(U).,Resource(R).,"has_permission(U, R, delete) :- User(U), Resource(R).","can_cancel_delete(U, R) :- User(U), Resource(R), has_permission(U, R, delete).","Student(?S) ∧ Error(?E) => can_acknowledge(?S,?E)"
the Basic Flow is re-started at the beginning.,User(U).,Flow(F).,"can_restart(U, F) :- User(U), Flow(F).","restart_flow(U, F) :- User(U), Flow(F), can_restart(U, F).","Student(?S) ∧ Schedule(?SC) ∧ owns_schedule(?S,?SC) => can_change_schedule(?S,?SC)"
The Student acknowledges the error.,Student(S).,Error(E).,"acknowledges(S, E) :- Student(S), Error(E).","can_acknowledge(S, E) :- Student(S), Error(E).","Professor(?P1) ∧ CourseOffering(?CO) ∧ assigned_to(?P1,?CO) ∧ ?(Professor(P2), P2 != ?P1, assigned_to(P2, CO)) => can_modify(?P1,?CO)"
The system must prevent students from changing any schedules other than their own,Student(S).,Schedule(SC).,"owns_schedule(S, SC) :- Student(S), Schedule(SC).","can_change_schedule(S, SC) :- Student(S), Schedule(SC), owns_schedule(S, SC).","Student(?S) ∧ Message(?M) ∧ registration_closed(?S) => display_message(?S,?M)"
The system must prevent professors from modifying assigned course offerings for other professors.,"Professor(P1), Professor(P2).",CourseOffering(CO).,"assigned_to(P1, CO) :- Professor(P1), CourseOffering(CO).","can_modify(P1, CO) :- Professor(P1), CourseOffering(CO), assigned_to(P1, CO), not (Professor(P2), P2 != P1, assigned_to(P2, CO)).","Registrar(?R) ∧ Message(?M) ∧ is_condition_met(?C) => display_message(?R,?M)"
"When the use case starts, if it is determined that registration for the current semester has been closed, a message is displayed to the Student.",Student(S).,Message(M).,registration_closed(S) :- Student(S).,"display_message(S, M) :- Student(S), Message(M), registration_closed(S).","Student(?S) ∧ Tuition(?T) ∧ Semester(?SE) ∧ enrolled_in(?S,?_,?SE) => calculate_tuition(?S,?T,?SE)"
"If it is, then a message is displayed to the Registrar",Registrar(R).,Message(M).,is_condition_met(C) :- Condition(C).,"display_message(R, M) :- Registrar(R), Message(M), is_condition_met(C).","System(?S) ∧ BillingSystem(?B) ∧ sends_transaction(?S,?B) => can_send_transaction(?S,?B)"
The system calculates the tuition owed by each student for his current semester schedule,Student(S).,"Semester(SE), Course(C), Tuition(T).","enrolled_in(S, C, SE) :- Student(S), Course(C), Semester(SE).","calculate_tuition(S, T, SE) :- Student(S), Tuition(T), Semester(SE), enrolled_in(S, _, SE).","Professor(?P) ∧ Message(?M) ∧ registration_closed(?S) ∧ current_semester(?S) => display_message(?P,?M)"
The system sends a transaction to the Billing System.,System(S).,BillingSystem(B).,"sends_transaction(S, B) :- System(S), BillingSystem(B).","can_send_transaction(S, B) :- System(S), BillingSystem(B), sends_transaction(S, B).","System(?S) ∧ CourseOffering(?CO) ∧ available(?CO) => can_retrieve(?S,?CO)"
"When the use case starts, if it is determined that registration for the current semester has been closed, a message is displayed to the Professor",Professor(P).,"Semester(S), Message(M).",registration_closed(S) :- Semester(S).,"display_message(P, M) :- Professor(P), Message(M), registration_closed(S), current_semester(S).","System(?S) ∧ Student(?ST) ∧ List(?L) ∧ has_access(?ST,?L) => can_display(?S,?ST,?L)"
The system retrieves a list of available course offerings from the Course Catalog System,"User(U), System(S).",CourseOffering(CO).,available(CO) :- CourseOffering(CO).,"can_retrieve(S, CO) :- System(S), CourseOffering(CO), available(CO).","System(?S) ∧ Course(?C) ∧ Database(?DB) ∧ has_access(?S,?DB) => can_access_course_info(?S,?C,?DB)"
The system displays the list to the Student.,"System(S), Student(ST).",List(L).,"has_access(ST, L) :- Student(ST), List(L).","can_display(S, ST, L) :- System(S), Student(ST), List(L), has_access(ST, L).","System(?NewSystem) ∧ CourseInfo(?CI) ∧ not from_legacy_database(?CI) => can_update(?NewSystem,?CI)"
The new system will access course information from the legacy database,System(S).,"Course(C), Database(DB).","has_access(S, DB) :- System(S), Database(DB).","can_access_course_info(S, C, DB) :- System(S), Course(C), Database(DB), has_access(S, DB).","Student(?S) ∧ ErrorMessage(?EM) ∧ acknowledges(?S,?EM) => can_acknowledge(?S,?EM)"
The new system will not update access course information from the legacy database.,System(NewSystem).,CourseInfo(CI).,from_legacy_database(CI) :- CourseInfo(CI).,"can_update(NewSystem, CI) :- System(NewSystem), CourseInfo(CI), not from_legacy_database(CI).",true => ?term in ?ate_use_case
The Student acknowledges the error message,Student(S).,ErrorMessage(EM).,"acknowledges(S, EM) :- Student(S), ErrorMessage(EM).","can_acknowledge(S, EM) :- Student(S), ErrorMessage(EM), acknowledges(S, EM).",
"the use case terminates.""",,,,terminate_use_case :- true.,
